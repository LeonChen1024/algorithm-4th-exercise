# E02.4.42

[TOC]

原来层序遍历的顺序是按每一层的顺序排列.而先序遍历的顺序是 自身,左节点,右节点.由于自身的下一个节点就是左节点,所以我们只需要求出右节点的位置即可.当树是满二叉树的时候情况最简单,左右子树大小均为(n-1)/2.所以根结点下标为0时,右子节点的下标时 (n+1)/2.根据完全二叉树原理可得, 二叉树高度 $k = \lfloor log_2^n \rfloor$ 根结点高度为0,当不是满二叉树的时候,相当于多了一层叶子节点,数量为 $l=n-2^k+1$.

此时去掉叶子节点就变成高度为 k-1 的满二叉树,节点数量为 $2^k -1$,左右子树大小为 $(2^k-2)/2=2^{k-1}-1$ .接着将多出的 l个节点分到左右子树. 第k层最多有 $2^k$ 个节点,每个子树最多分到 $2^k/2=2^{k-1}$ 个节点. 

可以得到当 $l \le 2^{k-1}$ 的时候,左右子树节点大小为 $2^{k-1}-1+l$ 和 $2^{k-1}-1$ .

当 $l > 2^{k-1}$ 时,左右子树节点大小为 $2^k-1$ 和 $2^{k-1}-1+l-2^{k-1} = l-1$

也就是说如果 $n-2^{k-1} < 2^k -1$ 那么是第一种情况, 末尾的 $2^{k-1}-1$ 个节点就是右子树.否则就是第二种情况,前面的 2^k 个节点就是根结点的左子树.

接下来的就是建堆的过程了,我们可以通过 sink 操作来建堆,由于左右节点只能通过大小来计算,所以我们要从上往下进行递归计算.我们对根结点进行计算左右节点和左右子树大小,然后分别对左右子树再进行sink,计算他们的左右节点和左右子树大小.当子树大小小于等1的时候说明是叶子节点,直接返回. 否则对比左右节点,和自身,将最大的节点放到自身节点.

排序的时候主要是使用 delMax 操作, 主要的逻辑和标准写法差不多,主要的差别是最后一个节点的计算,通过前面的公式我们可以通过左子树大小来判断,如果左子树小于等于 $2^k-1$ ,那么最后一个节点就在左子树,否则就在右子树.找到最后一个节点后将它保存起来,然后数组后面的元素向前补缺.然后将第一个节点放到最后一位,将保存的节点放到第一位,再对它进行sink即可.













